package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"apps/go-service/graph/model"
	"context"
	"math/rand"
)

// CastSpell is the resolver for the castSpell field.
func (r *mutationResolver) CastSpell(ctx context.Context, spell string, typeArg model.DamageType, playerID string) (*bool, error) {
  // ranodm damage between 1 and 10
  randomDmgFloat := rand.Float64() * 10

  spellToCast := model.CastedSpell{
  	Spell:    spell,
  	Type:     typeArg,
  	PlayerID: playerID,
  	Damage:   randomDmgFloat,
  }

  r.CastedSpells = append(r.CastedSpells, &spellToCast)

  r.mu.Lock()

  for _, observer := range r.SpellObservers {
    	observer <- &spellToCast
    }
  r.mu.Unlock()

  result := true

  return &result, nil
}

// SpellsCasted is the resolver for the spellsCasted field.
func (r *subscriptionResolver) SpellsCasted(ctx context.Context, target string) (<-chan *model.CastedSpell, error) {
  id := randString(8)
  spells := make(chan *model.CastedSpell, 1)

  go func() {
    <-ctx.Done()
    r.mu.Lock()
    delete(r.SpellObservers, id)
    r.mu.Unlock()
  }()

  r.mu.Lock()
  r.SpellObservers[id] = spells
  r.mu.Unlock()

  // r.SpellObservers[id] <- spells

  return spells, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
